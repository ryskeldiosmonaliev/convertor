#include <stdio.h>

#include "s21_decimal.h"
#include "supp_func.h"

int s21_negate(s21_decimal value, s21_decimal *result) {
  // @param value: Десятичное число, которое нужно инвертировать по знаку.
  // @param result: Указатель на переменную, в которую будет записан результат инверсии знака.
  // @return: Возвращает 1, если операция успешна, и 0, если указатель result равен NULL.

  int res = 1; // Переменная для хранения результата выполнения функции.

  // Проверяем, не равен ли указатель result NULL.
  if (result == NULL) {
    res = 0; // Если указатель result равен NULL, возвращаем 0 (ошибка).
  } else {
    // Если знак value равен 1 (отрицательный), меняем его на 0 (положительный).
    if (get_sign(value.bits[3]))
      set_bit(&(result->bits[3]), 31, 0); // Устанавливаем 31-й бит в 0 (положительный знак).
    else
      // Если знак value равен 0 (положительный), меняем его на 1 (отрицательный).
      set_bit(&(result->bits[3]), 31, 1); // Устанавливаем 31-й бит в 1 (отрицательный знак).
  }

  // Возвращаем результат выполнения функции: 1, если успешно, или 0 в случае ошибки.
  return res;
}


int s21_negate_big(s21_big_decimal value, s21_big_decimal *result) {
  // @param value: Большое десятичное число (s21_big_decimal), которое нужно инвертировать по знаку.
  // @param result: Указатель на переменную, в которую будет записан результат инверсии знака.
  // @return: Возвращает 1 после выполнения операции.

  int res = 1; // Переменная для хранения результата выполнения функции.

  // Проверяем знак value, который хранится в 31-м бите 6-го элемента массива bits.
  if (get_sign(value.bits[6])) {
    // Если знак value равен 1 (отрицательный), меняем его на 0 (положительный).
    set_bit(&(result->bits[6]), 31, 0);
  } else {
    // Если знак value равен 0 (положительный), меняем его на 1 (отрицательный).
    set_bit(&(result->bits[6]), 31, 1);
  }

  // Возвращаем результат выполнения функции (всегда 1).
  return res;
}


